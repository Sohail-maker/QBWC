using System;
using System.Collections;
using System.ComponentModel;
using System.Linq;
using System.Text.RegularExpressions;
using System.Web.Services;
using System.Windows.Forms;
using System.Xml.Linq;
using QuickbooksWebService.DomainModel;
using QuickbooksWebService.QuickbooksObjects;
using QuickbooksWebService.ResponseProcess;
using WebMatrix.Data;
using QuickbooksWebService.WebsiteObjects;
using WebMatrix.WebData;
namespace QwcService
{
	
	
	/// <summary>
	///	 Web Service Namespace="http://developer.intuit.com/",
	///	 Web Service Name="QWCPOSWebService",
	///	 Web Service Description="Sample WebService in ASP.NET to 
	///	 demonstrate QBWebConnector with QuickBooks POS
	/// </summary>
	[WebService(
		 Namespace="http://developer.intuit.com/",
		 Name="Infomedia Quickbooks Webconnector Service",
		 Description="Import web sales and customers into Quickbooks")]

	// Important Note: 	
	// You should keep the namespace as http://developer.intuit.com/ for all web 
	// services that communicates with QuickBooks Web Connector. 


	public class QwcService : System.Web.Services.WebService
	{
		#region GlobalVariables
		System.Diagnostics.EventLog evLog = new System.Diagnostics.EventLog();
		private int _count=0;
		private Repository rep;
		private bool _testing;
		public ArrayList req=new ArrayList();
		private enum Document
		{
			RequiresTaxUpdate,
			StepOneInventory,
			StepTwoInventory,
			Customer,
			Order
		}
		#endregion

		#region Constructor
		public QwcService()
		{
			//CODEGEN: This call is required by the ASP.NET 
			//Web Services Designer
			InitializeComponent();
			// Initializing EventLog for logging
			initEvLog();
			rep = new Repository();
			_testing = SystemInformation.ComputerName.ToLower() == "stickley";
		}
		#endregion

		#region AutoGeneratedMethods
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
	
		#endregion

		#region WebMethods
		
		[WebMethod]
		public string Test(int orderID)
		{
			var order = rep.GetQuickBooksOrder(false,orderID);
			var invoice = new FullInvoice();
			return	invoice.GetInvoice(order.CustomerID, orderID).ToString();
		}
		[WebMethod]
			/// <summary>
			/// WebMethod# 1 - clientVersion()
			/// To enable web service with QBWC version control
			/// Signature: public string clientVersion(string strVersion)
			///
			/// IN: 
			/// string strVersion
			///
			/// OUT: 
			/// string errorOrWarning
			/// Possible values: 
			/// string retVal
			/// - NULL or <emptyString> = QBWC will let the web service update
			/// - "E:<any text>" = popup ERROR dialog with <any text> 
			///					- abort update and force download of new QBWC.
			/// - "W:<any text>" = popup WARNING dialog with <any text> 
			///					- choice to user, continue update or not.
			/// </summary>
		public string clientVersion(string strVersion) {
			
			string retVal=null;
			double recommendedVersion  = 1.5;
			double supportedMinVersion = 1.0;
			double suppliedVersion=Convert.ToDouble(this.parseForVersion(strVersion));
			
			if(suppliedVersion<recommendedVersion) {
				retVal="W:We recommend that you upgrade your QBWebConnector";
			}
			else if(suppliedVersion<supportedMinVersion){
				retVal="E:You need to upgrade your QBWebConnector";
			}
			
			return retVal;
		}

		


		[WebMethod]
			/// <summary>
			/// WebMethod# 2 - authenticate()
			/// To verify username and password for the web connector that is trying to connect
			/// Signature: public string[] authenticate(string strUserName, string strPassword)
			/// 
			/// IN: 
			/// string strUserName 
			/// string strPassword
			///
			/// OUT: 
			/// string[] authReturn
			/// Possible values: 
			/// string[0] = ticket
			/// string[1]
			/// - empty string = use current company file
			/// - "none" = no further request/no further action required
			/// - "nvu" = not valid user
			/// - any other string value = use this company file
			/// </summary>
		public string[] authenticate(string strUserName, string strPassword) {
			
			string[] authReturn = new string[2];
			var ticket =  System.Guid.NewGuid().ToString();
			authReturn[0]= ticket;
			
			if (WebSecurity.Login(strUserName, strPassword))
			{
				var user = rep.GetUser(strUserName);
				var transaction = new Transaction(){
					ClientID = user.ClientID ?? 0,
					Guid = ticket,
					Date = DateTime.Now
				};
				rep.Add(transaction);
				rep.Save();
				var orders = rep.GetUnprocessedOrders(user.ClientID ?? 0);
				var customers = rep.GetUnprocessedCustomers(user.ClientID ?? 0);
				var newOrders =	orders.Select(o => o.TransactionID = transaction.TransactionID).ToList();
				var newCustomers = customers.Select(o => o.TransactionID = transaction.TransactionID).ToList();
				rep.Save();
				if(!newOrders.Any() && !newCustomers.Any() && (!user.Client.RequiresInventoryUpdate ?? false) && (!user.Client.RequiresTaxCodeUpdate ?? false))
					authReturn[1] = "none";
				// An empty string for authReturn[1] means asking QBWebConnector 
				// to connect to the company file that is currently openned in QB
				else
					authReturn[1]="";
			}
			else {
				authReturn[1]="nvu";
			}

			return authReturn;
		}


		[ WebMethod(Description="This web method facilitates web service to handle connection errors between QuickBooks and QBWebConnector",EnableSession=true) ]
			/// <summary>
			/// WebMethod# 3 - connectionError()
			/// To facilitate capturing of QuickBooks error and notifying it to web services
			/// Signature: public string connectionError (string ticket, string hresult, string message)
			///
			/// IN: 
			/// string ticket = A GUID based ticket string to maintain identity of QBWebConnector 
			/// string hresult = An HRESULT value thrown by QuickBooks when trying to make connection
			/// string message = An error message corresponding to the HRESULT
			///
			/// OUT:
			/// string retVal
			/// Possible values: 
			/// - “done” = no further action required from QBWebConnector
			/// - any other string value = use this name for company file
			/// </summary>
		public string connectionError(string ticket, string hresult, string message) {
			if (Session["ce_counter"] == null) {
				Session["ce_counter"] = 0;
			}
			
			string retVal=null;
			//-2147418113 = Can't connect to the database
			const string CANT_CONNECT_TO_DB="0x8000FFFF"; 
			// Add more as you need...

			if(hresult.Trim().Equals(CANT_CONNECT_TO_DB)){
				retVal = "DONE";
			}
			else { 
				// Depending on various hresults return different value 
				if((int)Session["ce_counter"]==0){
					// Try again with this company file
					retVal="Company Data=";
				}
				else{
					retVal = "DONE";
				}
			}
			Session["ce_counter"] = ((int) Session["ce_counter"]) + 1;
			return retVal;
		}
		[WebMethod]
		public string serverVersion()
		{
			return "";
		}

		[ WebMethod(Description="This web method facilitates web service to send request XML to QuickBooks via QBWebConnector",EnableSession=true) ]
			/// <summary>
			/// WebMethod# 4 - sendRequestXML()
			/// Signature: public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName, 
			/// string Country, int qbXMLMajorVers, int qbXMLMinorVers)
			/// 
			/// IN: 
			/// int qbXMLMajorVers
			/// int qbXMLMinorVers
			/// string ticket
			/// string strHCPResponse 
			/// string strCompanyFileName 
			/// string Country
			/// int qbXMLMajorVers
			/// int qbXMLMinorVers
			///
			/// OUT:
			/// string request
			/// Possible values: 
			/// - “any_string” = Request XML for QBWebConnector to process
			/// - "" = No more request XML 
			/// </summary>
		public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName, 
			string qbXMLCountry, int qbXMLMajorVers, int qbXMLMinorVers) {
			var db = Database.Open("Quickbooks");
			int? clientID = rep.GetUser(WebSecurity.CurrentUserId).ClientID;
			string request = "";
			var ireq = buildInfomediaRequest(ticket);
			var transID = rep.GetTransaction(ticket).TransactionID;
			int itotal = rep.GetCustomersByTransaction(transID).Count() + rep.GetOrdersByTransaction(transID).Count();
			_count = rep.GetUnprocessedCustomers(ticket).Count() + rep.GetUnprocessedOrders(ticket).Count();

			if (ireq != null && ireq.ToString() != String.Empty)
			{
				request = "<?xml version=\"1.0\" encoding=\"utf-8\"?>" + Environment.NewLine;
				request += ireq.ToString();
			}
			else
			{
				_count = 0;
				request = "";
			}
			
			if(WebSecurity.IsAuthenticated)
				return request;
			
			return"";
		}


		[ WebMethod(Description="This web method facilitates web service to receive response XML from QuickBooks via QBWebConnector",EnableSession=true) ]
			/// <summary>
			/// WebMethod# 5 - receiveResponseXML()
			/// Signature: public int receiveResponseXML(string ticket, string response, string hresult, string message)
			/// 
			/// IN: 
			/// string ticket
			/// string response
			/// string hresult
			/// string message
			///
			/// OUT: 
			/// int retVal
			/// Greater than zero  = There are more request to send
			/// 100 = Done. no more request to send
			/// Less than zero  = Custom Error codes
			/// </summary>
		public int receiveResponseXML(string ticket, string response, string hresult, string message) {
			var user = rep.GetUser(WebSecurity.CurrentUserId);
			rep.Add(new ResponseXML(){
				Date = DateTime.Now,
				Guid = ticket,
				Hresult = hresult,
				Message = message,
				Response = response,
				ClientID = user.ClientID ?? 0
			});
			rep.Save();

			
			string responseType = "";
			bool updatingInventory = false;
			var trans = rep.GetTransaction(ticket);
			
			int retVal=0;
			if(!hresult.ToString().Equals("")){
				// if there is an error with response received, web service could also return a -ve int		
				retVal=-101;
			}
			else{

				if (response.IndexOf("QBXMLMsgsRs") > 0)
				{
					var doc = XDocument.Parse(response);
					responseType = doc.Document.Root.Descendants("QBXMLMsgsRs").FirstOrDefault().Descendants().FirstOrDefault().Name.LocalName;
					switch(responseType)
					{
						case "CustomerAddRs":
							ProcessAddRs.ProcessCustomerAdd(doc,ticket);
							break;
						case "ItemQueryRs":
							ProcessQueryRs.InventoryQuery(response);
							break;
						case "InvoiceAddRs":
							ProcessAddRs.ProcessInvoiceAddRs(response, hresult, message);
							break;
						case "ItemSalesTaxQueryRs":
							ProcessQueryRs.ItemSalesTaxQueryRs(response);
							break;
						case "ItemSalesTaxAddRs":
							ProcessAddRs.ProcessSalesTaxAdd(response);
							break;
						case "ItemSalesTaxGroupQueryRs":
							ProcessQueryRs.ItemSalesTaxGroupQueryRs(response);
							break;
						case "ItemInventoryQueryRs":
							updatingInventory = true;
							ProcessQueryRs.ItemInventoryQueryRs(response);
							break;
						case "ItemNonInventoryQueryRs":
							ProcessQueryRs.ItemNonInventoryQueryRs(response);
							break;
						default:
							break;
					}
				}

				//Total Items to be processed for this transaction.
				int total=rep.GetOrdersByTransaction(trans.TransactionID).Count() + rep.GetCustomersByTransaction(trans.TransactionID).Count();
				
				//Remaining Items needing Processed
				int count= rep.GetUnprocessedOrdersByTransaction(ticket).Count() + rep.GetUnprocessedCustomersByTransaction(ticket).Count(); 
				
				decimal percentage = 100;
				if(total != 0)
				{
					percentage=100*((total-count))/total;
					
					if (percentage>=100)
					{
						count=0;
					}
				}
				retVal=Convert.ToInt32(percentage.ToString("N0"));
			}
			if (WebSecurity.IsAuthenticated)
				return updatingInventory ? 0 : retVal;
			
			return 100;
		}

		
		
		[WebMethod]
			/// <summary>
			/// WebMethod# 6 - getLastError()
			/// Signature: public string getLastError(string ticket)
			/// 
			/// IN:
			/// string ticket
			/// 
			/// OUT:
			/// string retVal
			/// Possible Values:
			/// Error message describing last web service error
			/// </summary>
		public string getLastError(string ticket) 
		{
			int errorCode=0;
			string retVal=null;
			if(errorCode==-101){
				retVal="QuickBooks was not running!"; // This is just an example of custom user errors
			}
			else{
				retVal="";
			}
			
			return retVal;
		}




		[WebMethod]
			/// <summary>
			/// WebMethod# 7 - closeConnection()
			/// At the end of a successful update session, QBWebConnector will call this web method.
			/// Signature: public string closeConnection(string ticket)
			/// 
			/// IN:
			/// string ticket 
			/// 
			/// OUT:
			/// string closeConnection result 
			/// </summary>
		public string closeConnection(string ticket)
		{
			string retVal=null;
			retVal="OK";
			WebSecurity.Logout();
			return retVal;
		}
	
		#endregion
		
		#region UtilityMethods
		private void initEvLog() {
			try
			{
				string source="WCWebService";
				if (!System.Diagnostics.EventLog.SourceExists(source))
					System.Diagnostics.EventLog.CreateEventSource(source, "Application");
				evLog.Source = source;
			}
			catch{};
			return;
		}

		private void logEvent(string logText) {
			try
			{
				evLog.WriteEntry(logText);
			}
			catch{};
			return;
		}

		private XDocument buildInfomediaRequest(string ticket){
			var rep = new Repository();
			var docMaker = new CustomerAdd();
			var user = rep.GetUser(WebSecurity.CurrentUserId);
			bool requiresInventoryUpdate = user.Client.RequiresInventoryUpdate ?? false;
			bool requiresTaxCodeUpdate = user.Client.RequiresTaxCodeUpdate ?? false;
			var customer = rep.GetUnprocessedCustomersByTransaction(ticket).FirstOrDefault();
			var order = rep.GetUnprocessedOrdersByTransaction(ticket).FirstOrDefault();
			var transaction = rep.GetTransaction(ticket);
			if(requiresTaxCodeUpdate && transaction.ProcessedItemSalesTaxQueryRs != true)
			{
				var doc =  SalesTax.ItemSalesTaxQueryRq;
				transaction.ProcessedItemSalesTaxQueryRs = true;
				rep.Save();
				return doc;
			}
			else if(requiresTaxCodeUpdate)
			{
				var doc =  SalesTax.ItemSalesTaxGroupQueryRq;
				user.Client.RequiresTaxCodeUpdate = false;
				rep.Save();
				return doc;
			}
			else if(requiresInventoryUpdate && transaction.ProcessedItemInventoryQuery != true)
			{
				var doc = Inventory.ItemInventoryFullQueryRq();
				transaction.ProcessedItemInventoryQuery = true;
				rep.Save();
				return doc;
			}
			else if(requiresInventoryUpdate)
			{
				if(user.Client.IsContentEditsShop ?? false)
				{
					UpdateShopInventory();
				}
				var doc =  Inventory.ItemNonInventoryFullQueryRq();
				user.Client.RequiresInventoryUpdate = false;
				rep.Save();
				return doc;
			}
			else if(customer != null)
			{
				var doc = docMaker.GetCustomer(customer.CustomerID,customer.Orders.FirstOrDefault().OrderNumber);
				customer.CurrentRequest = true;
				customer.Reported = true;
				rep.Save();
				return doc;
			}
			if (order.AmountDiscount != null && order.AmountDiscount > 0 )
			{
				Error.ProcessFailedOrder(order);
				order.Reported = true;
				rep.Save();
				order = rep.GetUnprocessedOrdersByTransaction(ticket).FirstOrDefault();
			}
			else if ( order != null)
			{
				var fullinvoice = new FullInvoice();
				//var invoice = new Invoice();
				
				var doc =	fullinvoice.GetInvoice(order.Customer.CustomerID, order.OrderID);
				order.Reported = true;
				rep.Save();
				return doc;
			}
			return null;
		}
		
		[WebMethod]
		
		public void TestCustomerResponse()
		{
			ProcessAddRs.ProcessCustomerAdd(XDocument.Parse("<?xml version=\"1.0\" ?> <QBXML> <QBXMLMsgsRs> <InvoiceAddRs requestID=\"1297\" statusCode=\"3070\" statusSeverity=\"Error\" statusMessage=\"The string &quot;Graham-Lees Hall 334, Washington and Lee University&quot; in the field &quot;Addr2&quot; is too long.\" /> </QBXMLMsgsRs> </QBXML> "),"0d4f37ec-96f8-425e-8534-c7733ed0c0e8");
		}

		private void UpdateShopInventory()
		{
			var user = rep.GetUser(WebSecurity.CurrentUserId);
			if(user.Client.IsContentEditsShop ?? false)
			{
				WebShopInventory.GetCeInventory(user);
			}
			else
			{
				WebShopInventory.GetShopInventory();
			}
		}

		
		
		

		private string parseForVersion(string input){
			// This method is created just to parse the first two version components
			// out of the standard four component version number:
			// <Major>.<Minor>.<Release>.<Build>
			// 
			// As long as you get the version in right format, you could use
			// any algorithm here. 
			string retVal="";
			string major="";
			string minor="";
			Regex version = new Regex(@"^(?<major>\d+)\.(?<minor>\d+)(\.\w+){0,2}$", RegexOptions.Compiled);
			Match versionMatch= version.Match(input);
			if (versionMatch.Success){
				major= versionMatch.Result("${major}");							
				minor= versionMatch.Result("${minor}");							
				retVal=major+"."+minor;
			}
			else{
				retVal=input;
			}
			return retVal;
		}
		
		#endregion
	}
}
